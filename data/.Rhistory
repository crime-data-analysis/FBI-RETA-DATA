######
## THIS SCRIPT LOADS THE RETURN A MASTER FILE DATA INTO A POSTGREST DATABASE
## EACH MASTER FILE IS READ INTO A SEPERATE TABLE FOR NOW TO HELP WITH ERROR SPOTTING
## EVENTUALLY IT WILL ALL BE READ INTO A SINGLE TABLE.
######
# Set the working directory
setwd("/Users/don/Google Drive/UCR Data Munge/FBI RETA DATA")
# Run a script the creates information about the variables, clean up, and read it in that information.
source("set up variables.R")  # run the script
rm(list = ls())  # clean out variables (remove all variables in the workspace)
gc()  # clean up memmory (garbage collection)
load("field.info.RData")  # read in the data created by the
# JUST A SIMPLE FUNCTION TO COUNT THE LINES IN A FILE
count.lines <- function(file.name){
library(R.utils)
num.lines <- countLines(file.name)
detach("package:R.utils")
return(num.lines)
}
# A FUNCTION THAT READS 100 LINES OF DATA FROM THE FIXED WIDTH FILE
read.in.data <- function(file.name, field.widths, field.types, field.names, skip.num, chunk.size) {
out <- tryCatch(
out <- read.fwf(file=file.name,
field.widths,
colClasses="character",
col.names=field.names,
skip=skip.num,
n=chunk.size,
fill=TRUE,
blank.lines.skip=TRUE,
flush=TRUE),
error=function(cond) {
message(paste("This chunk threw an error:", skip.num + 1, ":", skip.num + 100, sep=""))
message("Here's the original error message:")
message(cond)
return(NA) # Choose a return value in case of error
},
warning=function(cond) {
message(paste("This chunk generated a warning:", skip.num, ":", skip.num + 100, sep=""))
message("Here's the original error message:")
message(cond)
return(NA) # Choose a return value in case of error
},
finally={
# Nothing to do here.  Maybe post a message?
}
)
return(out)
}
##########
# TESTING
##########
# SETUP CONNNECTION TO POSTGRES & HAVE A LOOK
library(RPostgreSQL)
drv <- dbDriver("PostgreSQL")  # specify driver for postgresql
dbGetInfo(drv)  # have a quick look at my connection (id, etc.)
dbDisconnect(dbListConnections(drv)[[1]])
con <- dbConnect(drv, dbname="ucr_db")  # set up a connection to the db
summary(con)   #
dbListTables(con)
if(dbExistsTable(con, "return_a")) dbRemoveTable(con,"return_a")
for(year.num in 1960) {
file.name <- paste("KCRETA", year.num, ".DAT", sep="")
num.lines <- count.lines(file.name)
chunk.size <- 250
num.chunks <- trunc(num.lines/chunk.size)
remainder <- (num.lines - (num.chunks*chunk.size))
print(paste("file: ", year.num, "; lines: ", num.lines, sep=""))
table.name <- paste0("return_a_", year.num)
# PARSE DATA
for(chunk.num in 0:num.chunks){
skip.num <- chunk.num*chunk.size
print(paste0("processing lines: ",
skip.num + 1 , ":", skip.num + chunk.size,
" out of ", num.lines,
" in ", file.name, " ", Sys.time() ))
if(chunk.num == num.chunks) {
read.num <- remainder} else {
read.num <- chunk.size}
one.chunk <- read.in.data(file.name, field.widths, field.types, field.names, skip.num, read.num)
one.chunk[, c(16, 19:23, 37, 48:159, 174:285, 300:411, 426:537, 552:663, 678:789,
804:915, 930:1041, 1056:1167, 1182:1293, 1308:1419,1434:1545)] <- sapply(one.chunk[,c(
16, 19:23, 37, 48:159, 174:285, 300:411, 426:537, 552:663, 678:789,
804:915, 930:1041, 1056:1167, 1182:1293, 1308:1419,1434:1545)], as.integer)
if(chunk.num == 0) {
if (dbExistsTable(con, table.name)) dbRemoveTable(con, table.name)
dbWriteTable(con, table.name, one.chunk, append = F, row.names = F)
} else {
dbWriteTable(con, table.name, one.chunk, append = T, row.names = F)
}
}
}
######
## THIS SCRIPT LOADS THE RETURN A MASTER FILE DATA INTO A POSTGREST DATABASE
## EACH MASTER FILE IS READ INTO A SEPERATE TABLE FOR NOW TO HELP WITH ERROR SPOTTING
## EVENTUALLY IT WILL ALL BE READ INTO A SINGLE TABLE.
######
# Set the working directory
setwd("/Users/don/Google Drive/UCR Data Munge/FBI RETA DATA")
# Run a script the creates information about the variables, clean up, and read it in that information.
source("set up variables.R")  # run the script
rm(list = ls())  # clean out variables (remove all variables in the workspace)
gc()  # clean up memmory (garbage collection)
load("field.info.RData")  # read in the data created by the
# JUST A SIMPLE FUNCTION TO COUNT THE LINES IN A FILE
count.lines <- function(file.name){
library(R.utils)
num.lines <- countLines(file.name)
detach("package:R.utils")
return(num.lines)
}
# A FUNCTION THAT READS 100 LINES OF DATA FROM THE FIXED WIDTH FILE
read.in.data <- function(file.name, field.widths, field.types, field.names, skip.num, chunk.size) {
out <- tryCatch(
out <- read.fwf(file=file.name,
field.widths,
colClasses="character",
col.names=field.names,
skip=skip.num,
n=chunk.size,
fill=TRUE,
blank.lines.skip=TRUE,
flush=TRUE),
error=function(cond) {
message(paste("This chunk threw an error:", skip.num + 1, ":", skip.num + 100, sep=""))
message("Here's the original error message:")
message(cond)
return(NA) # Choose a return value in case of error
},
warning=function(cond) {
message(paste("This chunk generated a warning:", skip.num, ":", skip.num + 100, sep=""))
message("Here's the original error message:")
message(cond)
return(NA) # Choose a return value in case of error
},
finally={
# Nothing to do here.  Maybe post a message?
}
)
return(out)
}
##########
# TESTING
##########
# SETUP CONNNECTION TO POSTGRES & HAVE A LOOK
library(RPostgreSQL)
drv <- dbDriver("PostgreSQL")  # specify driver for postgresql
dbGetInfo(drv)  # have a quick look at my connection (id, etc.)
dbDisconnect(dbListConnections(drv)[[1]])
con <- dbConnect(drv, dbname="ucr_db")  # set up a connection to the db
summary(con)   #
dbListTables(con)
if(dbExistsTable(con, "return_a")) dbRemoveTable(con,"return_a")
for(year.num in 1961:2011) {
file.name <- paste("KCRETA", year.num, ".DAT", sep="")
num.lines <- count.lines(file.name)
chunk.size <- 250
num.chunks <- trunc(num.lines/chunk.size)
remainder <- (num.lines - (num.chunks*chunk.size))
print(paste("file: ", year.num, "; lines: ", num.lines, sep=""))
table.name <- paste0("return_a_", year.num)
# PARSE DATA
for(chunk.num in 0:num.chunks){
skip.num <- chunk.num*chunk.size
print(paste0("processing lines: ",
skip.num + 1 , ":", skip.num + chunk.size,
" out of ", num.lines,
" in ", file.name, " ", Sys.time() ))
if(chunk.num == num.chunks) {
read.num <- remainder} else {
read.num <- chunk.size}
one.chunk <- read.in.data(file.name, field.widths, field.types, field.names, skip.num, read.num)
one.chunk[, c(16, 19:23, 37, 48:159, 174:285, 300:411, 426:537, 552:663, 678:789,
804:915, 930:1041, 1056:1167, 1182:1293, 1308:1419,1434:1545)] <- sapply(one.chunk[,c(
16, 19:23, 37, 48:159, 174:285, 300:411, 426:537, 552:663, 678:789,
804:915, 930:1041, 1056:1167, 1182:1293, 1308:1419,1434:1545)], as.integer)
if(chunk.num == 0) {
if (dbExistsTable(con, table.name)) dbRemoveTable(con, table.name)
dbWriteTable(con, table.name, one.chunk, append = F, row.names = F)
} else {
dbWriteTable(con, table.name, one.chunk, append = T, row.names = F)
}
}
}
###########
## This script creates information about the fixed-width fields in the FBI UCR Return A Master File.
## Specifically, it creates three lists: (1) field names, (2) field widths, and (3) field types.
## The lists are then saved to a file ("reta.field.info.RData") that can be used by other scripts.
###########
### CREATE VARIABLE NAMES
### The file header only occurs once, so we create a seperate list of the fields in it.
file.header.names <- c("id", "state", "ori_code", "group", "division", "year", "sequence", "juv_age", "core_ci", "covered_by", "ori_group", "last_update", "field_office", "num_months", "agency_count", "population", "county", "msa", "county2", "county3", "county1_pop", "county2_pop", "county3_pop", "pop_source", "follow_up", "special_mail_group", "special_mail_addr", "agency_name", "agency_state", "address1", "address2", "address3", "address4", "zip", "old_pop_group", "unused_header")
# The monthly header names occur twelve times in each row
monthly.header.names <- c("month_in", "date_last_update", "card_0_type", "card_1_type", "card_2_type", "card_3_type", "card_4_type", "card_0_pt", "card_1_pt", "card_2_pt", "card_3_pt")
# crime card prefixes describe  cards 0, 1, 2, and 3, respecrtively.
crime.card.prefixes <- c("unfounded_", "actual_", "cleared_", "cleared_u18_")
# these crime descriptions are appended to the crime prefixes for each month.
cards.0123.names <- c("murder", "manslaughter", "rape_total", "rape_by_force", "rape_attempt", "robbery", "robbery_gun", "robbery_knife", "robbery_othweap", "robbery_strong_arm", "assault", "assault_gun", "assault_knife", "assault_othweap", "assault_hands", "assault_simple", "burglary", "burglary_forcible_entry", "burglary_no_forcible_entry", "burglary_attempt", "larceny", "motor_vehicle_theft", "auto_theft", "truck_bus_theft", "other_vehicle_theft", "total_all_fields", "larceny_under_50_dollars", "unused")
# use a simple lapply to join the prefixes and card descriptions.
cards <- lapply(crime.card.prefixes, function(x) paste(x, cards.0123.names, sep = ""))
# officer injury cards occur once per month after each crime card.
card.4.names <- c("officers_killed_felony", "officers_killed_accident", "officers_assaulted")
# combine the header, the various types of reported crimes, and the officer injuries into a single list.
card.names <- c(monthly.header.names, unlist(cards), card.4.names)
# create a list of month prefixes
month.prefixes <- c("jan_", "feb_", "mar_", "apr_", "may_", "jun_", "jul_", "aug_", "sep_", "oct_", "nov_", "dec_")
# ccombien the month prefixes with each of the monthly card names
twelve.cards <- lapply(month.prefixes, function(x) paste(x, card.names, sep = ""))
# stick on the file hearder names and we're done!
field.names <- c(file.header.names, unlist(twelve.cards))
### DEFINE VARIABLE WIDTHS
# This is basically the same combination recipe as with field names except
# it's a bit less involved as we don't need unique widths for each month.
file.header.widths <- c(1, 2, 7, 2, 1, 2, 5, 2, 1, 7, 1, 6, 4, 2, 1, 9, 3, 3, 15, 15, 9, 9, 9, 1, 1, 1, 1, 24, 6, 30, 30, 30, 30, 5, 1, 29)
monthly.header.widths <- c(2, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1)
cards.0123.widths <- c(5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5)
card.4.widths <- c(3, 3, 7)
mw <- c(monthly.header.widths, rep(cards.0123.widths, 4), card.4.widths) # monthly field widths
field.widths <- c(file.header.widths, rep(mw, 12))
sum(field.widths) # check to make sure it adds up to 7385
### DEFINE VARIABLE TYPES
# This is basically the same combination recipe as with field names except
# it's a bit less involved as we don't need unique types for each month.
file.header.types <- c(rep("character", 15), "numeric", rep("character", 2), rep("numeric", 5), rep("character", 13) )
monthly.header.types <- c(rep("character", 11))
cards.0123.types <- c(rep("numeric",28))
card.4.types <- c(rep("character", 3))
mt <- c(monthly.header.types, rep(cards.0123.types, 4), card.4.types) # monthly field widths
field.types <- c(file.header.types, rep(mt, 12))
### SAVE THE LISTS TO A FILE AND WE'RE DONE!
setwd("/Users/don/Google Drive/UCR Data Munge/FBI RETA DATA")
save(field.names, field.widths, field.types, file="reta.field.info.RData")
######
## THIS SCRIPT LOADS THE RETURN A MASTER FILE DATA INTO A POSTGREST DATABASE
## EACH MASTER FILE IS READ INTO A SEPERATE TABLE FOR NOW TO HELP WITH ERROR SPOTTING
## EVENTUALLY IT WILL ALL BE READ INTO A SINGLE TABLE.
######
# Set the working directory
setwd("/Users/don/Google Drive/UCR Data Munge/RCODE")
# Run a script the creates information about the variables, clean up, and read it in that information.
source("set up variables.R")  # run the script
setwd("/Users/don/Google Drive/UCR Data Munge/FBI RETA DATA")
rm(list = ls())  # clean out variables (remove all variables in the workspace)
gc()  # clean up memmory (garbage collection)
load("field.info.RData")  # read in the data created by the
# JUST A SIMPLE FUNCTION TO COUNT THE LINES IN A FILE
count.lines <- function(file.name){
library(R.utils)
num.lines <- countLines(file.name)
detach("package:R.utils")
return(num.lines)
}
load("reta.field.info.RData")  # read in the data created by the
# JUST A SIMPLE FUNCTION TO COUNT THE LINES IN A FILE
count.lines <- function(file.name){
library(R.utils)
num.lines <- countLines(file.name)
detach("package:R.utils")
return(num.lines)
}
# A FUNCTION THAT READS 100 LINES OF DATA FROM THE FIXED WIDTH FILE
read.in.data <- function(file.name, field.widths, field.types, field.names, skip.num, chunk.size) {
out <- tryCatch(
out <- read.fwf(file=file.name,
field.widths,
colClasses="character",
col.names=field.names,
skip=skip.num,
n=chunk.size,
fill=TRUE,
blank.lines.skip=TRUE,
flush=TRUE),
error=function(cond) {
message(paste("This chunk threw an error:", skip.num + 1, ":", skip.num + 100, sep=""))
message("Here's the original error message:")
message(cond)
return(NA) # Choose a return value in case of error
},
warning=function(cond) {
message(paste("This chunk generated a warning:", skip.num, ":", skip.num + 100, sep=""))
message("Here's the original error message:")
message(cond)
return(NA) # Choose a return value in case of error
},
finally={
# Nothing to do here.  Maybe post a message?
}
)
return(out)
}
##########
# TESTING
##########
# SETUP CONNNECTION TO POSTGRES & HAVE A LOOK
library(RPostgreSQL)
drv <- dbDriver("PostgreSQL")  # specify driver for postgresql
dbGetInfo(drv)  # have a quick look at my connection (id, etc.)
dbDisconnect(dbListConnections(drv)[[1]])
con <- dbConnect(drv, dbname="ucr_db")  # set up a connection to the db
summary(con)   #
dbListTables(con)
if(dbExistsTable(con, "return_a")) dbRemoveTable(con,"return_a")
for(year.num in 1961:2011) {
file.name <- paste("KCRETA", year.num, ".DAT", sep="")
num.lines <- count.lines(file.name)
chunk.size <- 250
num.chunks <- trunc(num.lines/chunk.size)
remainder <- (num.lines - (num.chunks*chunk.size))
print(paste("file: ", year.num, "; lines: ", num.lines, sep=""))
table.name <- paste0("return_a_", year.num)
# PARSE DATA
for(chunk.num in 0:num.chunks){
skip.num <- chunk.num*chunk.size
print(paste0("processing lines: ",
skip.num + 1 , ":", skip.num + chunk.size,
" out of ", num.lines,
" in ", file.name, " ", Sys.time() ))
if(chunk.num == num.chunks) {
read.num <- remainder} else {
read.num <- chunk.size}
one.chunk <- read.in.data(file.name, field.widths, field.types, field.names, skip.num, read.num)
one.chunk[, c(16, 19:23, 37, 48:159, 174:285, 300:411, 426:537, 552:663, 678:789,
804:915, 930:1041, 1056:1167, 1182:1293, 1308:1419,1434:1545)] <- sapply(one.chunk[,c(
16, 19:23, 37, 48:159, 174:285, 300:411, 426:537, 552:663, 678:789,
804:915, 930:1041, 1056:1167, 1182:1293, 1308:1419,1434:1545)], as.integer)
if(chunk.num == 0) {
if (dbExistsTable(con, table.name)) dbRemoveTable(con, table.name)
dbWriteTable(con, table.name, one.chunk, append = F, row.names = F)
} else {
dbWriteTable(con, table.name, one.chunk, append = T, row.names = F)
}
}
}
psql.statement <- paste("SELECT *
INTO ucr_ret_a
FROM (SELECT * FROM return_a_1960)
AS tmp")
dbSendQuery(con, psql.statement)
psql.statement <- paste("INSERT INTO ucr_ret_a
SELECT * FROM return_a_",
year.num, sep="")
psql.statement
psql.statement <- paste("INSERT INTO ucr_ret_a ",
"SELECT * FROM return_a_",
year.num, sep="")
psql.statement
for (year.num in 1961:2011){
psql.statement <- paste("INSERT INTO ucr_ret_a ",
"SELECT * FROM return_a_",
year.num, sep="")
dbSendQuery(con, psql.statement)
}
print("yay!")
for (year.num in 1960:2011){
table.name <- paste0("return_a_", year.num)
dbRemoveTable(con,table.name)
}
dbCommit(con)
dbListConnections(drv)
dbDisconnect(dbListConnections(drv)[[1]])      #
dbListConnections(drv)
list()
dbListConnections(drv) != list()
dbListConnections(drv) == list())
dbListConnections(drv) == list()
dbListConnections(drv)
con <- dbConnect(drv, dbname="ucr_db")         # set up a connection to the db
dbListConnections(drv)
dbListConnections(drv)[[1]]
dbListConnections(drv)[[1]]
dbDisconnect(dbListConnections(drv)[[1]])      # disconnect an existing connection if one is open
dbListConnections(drv)[[1]]
as.logical(dbListConnections(drv)[[1]])
tryCatch(dbListConnections(drv)[[1]],
error=function(cond),
warning=function(cond),
finally=function(cond))
discon.result < dbListConnections(drv)[[1]]
discon.result <- dbListConnections(drv)[[1]]
dbListConnections(drv)
str(dbListConnections(drv))
len(dbListConnections(drv))
length(dbListConnections(drv))
con <- dbConnect(drv, dbname="ucr_db")         # set up a connection to the db
length(dbListConnections(drv))
dbListTables(con)                              # list the tables in the database
